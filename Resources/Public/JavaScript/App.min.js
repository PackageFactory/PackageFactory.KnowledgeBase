(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _reductAssembler = require('@reduct/assembler');

var _reductAssembler2 = _interopRequireDefault(_reductAssembler);

var app = (0, _reductAssembler2['default'])();

app.run();

},{"@reduct/assembler":2}],2:[function(require,module,exports){
(function (process,global){
/**
 *
 * @name @reduct/assembler
 * @version 1.0.1
 * @license MIT
 *
 * @author Tyll Weiß <inkdpixels@gmail.com>
 * @author André König <andre.koenig@posteo.de>
 * @author Wilhelm Behncke
 *
 */

"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (factory) {
    var opts = {
        isTestingEnv: process && process.title && !! ~process.title.indexOf('reduct'),
        packageVersion: {
            major: 1,
            minor: 0,
            patch: 1
        }
    };
    var world = this;

    // Check for globals.
    if (typeof window !== "undefined") {
        world = window;
    } else if (typeof global !== "undefined") {
        world = global;
    } else if (typeof self !== "undefined") {
        world = self;
    }

    // Initiate the global reduct object if necessary.
    if (!world.reduct) {
        world.reduct = {};
    }

    // Export the factory with the global and options to all module formats.
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = factory(world, opts);
    } else if (typeof define === "function" && define.amd) {
        define([], function () {
            return factory(world, opts);
        });
    } else {
        world.reduct.assembler = factory(world, opts);
    }
})(function factory(global, factoryOpts) {

    /**
     * The Assembler.
     *
     * An assembler instance acts as the central point of your
     * application. It is responsible for connecting DOM nodes with
     * actual component instances through exposed interfaces. Those
     * interfaces provides the functionality for registering component
     * classes and bootstrapping the whole application.
     *
     * Usage example:
     *
     *     import assembler from 'assembler';
     *
     *     // Importing your actual components
     *     import MyComponent from 'my-component';
     *     import AnotherComponent from 'another-component';
     *
     *     const app = assembler();
     *
     *     app.register(MyComponent);
     *     app.register(AnotherComponent, 'NewsComponent');
     *
     *     // Start the application (will parse the DOM and mount the
     *     // component instances).
     *     app.run();
     *
     */

    var Assembler = (function () {

        /**
         * Initializes the empty component class index
         * and the actual component instance cache.
         *
         */

        function Assembler() {
            var opts = arguments.length <= 0 || arguments[0] === undefined ? { marker: 'component' } : arguments[0];

            _classCallCheck(this, Assembler);

            this.marker = opts.marker;
            this.selector = "data-" + this.marker;

            this.index = {};

            //
            // The actual instantiated components.
            //
            // Structure:
            //
            //     {
            //         'ComponentClassName': [object, object],
            //         'YetAnotherComponentClassName': [object]
            //     }
            //
            this.components = {};

            //
            // A cache of DOM elements.
            //
            // This is for checking if a component has already been instantiated.
            //
            // TODO: Refactoring: Find another way (with good performance) to combine this
            // array with the `components` object.
            //
            this.elements = [];
        }

        //
        // Create the `assembler` factory function.
        // This factory will create a new instance of the `assembler` and exposes the API
        //

        /**
         * @private
         *
         * Checks if a component has already been instantiated.
         *
         * @param {DOMElement} element The element which should be connected to a component.
         *
         * @returns {boolean}
         *
         */

        _createClass(Assembler, [{
            key: "isInstantiated",
            value: function isInstantiated(element) {
                return !! ~this.elements.indexOf(element);
            }

            /**
             * @private
             *
             * Instantiates a component by a given DOM node.
             *
             * Will extract the component's name out of the DOM nodes `data`
             * attribute, instantiates the actual component object and pushes
             * the instance to the internal `components` index.
             *
             * @param {HTMLElement} element The component's root DOM node.
             *
             */
        }, {
            key: "instantiate",
            value: function instantiate(element) {
                if (!this.isInstantiated(element)) {
                    var _name = element.getAttribute(this.selector);

                    var components = this.components[_name] = [].slice.call(this.components[_name] || []);
                    var Component = this.index[_name];

                    this.elements.unshift(element);

                    components.unshift(new Component(element));
                }
            }

            /**
             * Registers a component class.
             *
             * Usage example
             *
             *     app.register(MyComponent); // Name: 'MyComponent'
             *
             *     app.register(MyComponent, 'FooComponent'); // Name: 'FooComponent'
             *
             * @param {Function} ComponentClass The component class which should be registered.
             * @param {string} name An alternative name (optional)
             *
             */
        }, {
            key: "register",
            value: function register(ComponentClass, name) {
                var type = typeof ComponentClass;

                if (type !== 'function') {
                    throw new Error("'" + type + "' is not a valid component class.");
                }

                name = name || ComponentClass.name;

                this.index[name] = ComponentClass;
            }

            /**
             * Takes a hashmap with multiple component classes
             * and registers them at once.
             *
             * Usage example:
             *
             *     app.registerAll({
             *         MyComponent: MyComponent,        // name: 'MyComponent'
             *         'AnotherComponent': FooComponent // name: 'AnotherComponent'
             *     });
             *
             *     // With destructuring
             *     app.registerAll({MyComponent, FooComponent});
             *
             * @param {object} classMap A map with multiple component classes.
             *
             */
        }, {
            key: "registerAll",
            value: function registerAll(classMap) {
                var _this = this;

                Object.keys(classMap).forEach(function (name) {
                    return _this.register(classMap[name], name);
                });
            }

            /**
             * "Parse" the DOM for component declarations and
             * instantiate the actual, well, components.
             *
             */
        }, {
            key: "run",
            value: function run() {
                var _this2 = this;

                var elements = [].slice.call(document.querySelectorAll("[" + this.selector + "]"));
                var names = Object.keys(this.index);

                //
                // Find all instantiable elements.
                // Note: `getAttribute` has to be used due to: https://github.com/tmpvar/jsdom/issues/961
                //
                elements.filter(function (element) {
                    return !! ~names.indexOf(element.getAttribute(_this2.selector));
                }).forEach(function (element) {
                    return _this2.instantiate(element);
                });
            }
        }]);

        return Assembler;
    })();

    var assembler = function assembler(opts) {
        var assembler = new Assembler(opts);

        //
        // Shard the actual front-facing API (for not leaking private methods and properties).
        //
        var api = {
            register: function register(ComponentClass, name) {
                return assembler.register(ComponentClass, name);
            },
            registerAll: function registerAll(classMap) {
                return assembler.registerAll(classMap);
            },
            run: function run() {
                return assembler.run();
            }
        };

        //
        // Expose additional attributes for the tests.
        //
        if (factoryOpts.isTestingEnv) {
            api.index = assembler.index;
            api.components = assembler.components;
        }

        return api;
    };

    //
    // Add the version information to the factory function.
    //
    assembler.version = factoryOpts.packageVersion;

    return assembler;
});
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":3}],3:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[1]);
